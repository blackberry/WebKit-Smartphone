/*
 * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
 */

#include "config.h"
#include "BackingStore.h"
#include "BackingStore_p.h"

#include "CString.h"
#include "EGLDisplayOpenVG.h"
#include "EGLUtils.h"
#include "FloatRect.h"
#include "IntRect.h"
#include "IntRectRegion.h"
#include "IntSize.h"
#include "PainterOpenVG.h"
#include "PlatformString.h"
#include "SurfaceOpenVG.h"
#include "SurfacePool.h"
#include "TiledImageOpenVG.h"
#include "TransformationMatrix.h"
#include "WebPage.h"
#include "WebPage_p.h"
#include "WebPageClient.h"
#include "WebSettings.h"

#include <math.h>
#include <wtf/CurrentTime.h>
#include <wtf/ListHashSet.h>
#include <wtf/MathExtras.h>
#include <wtf/NotFound.h>

#define ENABLE_SCROLLBARS 1
#define ENABLE_REPAINTONSCROLL 1
#define DEBUG_BACKINGSTORE 0
#define DEBUG_TILEMATRIX 0

using std::min;
using std::max;
using namespace WebCore;

namespace Olympia {
namespace WebKit {

/* Compute divisor pairs */
typedef std::pair<int, int> Divisor;
typedef Vector<Divisor> DivisorList;
// TODO: cache this and/or use a smarter algorithm
static DivisorList divisors(int n)
{
    DivisorList divisors;
    for (unsigned int i = 1; i <= n; ++i)
        if (!(n % i))
            divisors.append(std::make_pair(i, n / i));
    return divisors;
}

/* Compute best divisor given the ratio determined by size */
static Divisor bestDivisor(WebCore::IntSize size, int tileWidth, int tileHeight,
                           int minimumNumberOfTilesWide, int minimumNumberOfTilesHigh,
                           BackingStorePrivate::TileMatrixDirection direction)
{
    // The point of this function is to determine the number of tiles in each
    // dimension.  We do this by looking to match the tile matrix width/height
    // ratio as closely as possible with the width/height ratio of the contents.
    // We also look at the direction passed to give preference to one dimension
    // over another. This method could probably be made faster, but it gets the
    // job done.

    SurfacePool* surfacePool = SurfacePool::globalSurfacePool();
    ASSERT(!surfacePool->isEmpty());

    // Store a static list of possible divisors
    static DivisorList divisorList = divisors(surfacePool->size());

    // The ratio we're looking to best imitate
    float ratio = static_cast<float>(size.width()) / static_cast<float>(size.height());

    Divisor bestDivisor;
    for (size_t i = 0; i < divisorList.size(); ++i) {
        Divisor divisor = divisorList[i];

        bool divisorWidthIsPerfect = size.width() <= divisor.first * tileWidth && abs(size.width() - divisor.first * tileWidth) < tileWidth;
        bool divisorHeightIsPerfect = size.height() <= divisor.second * tileHeight && abs(size.height() - divisor.second * tileHeight) < tileHeight;
        bool divisorWidthIsValid = divisor.first >= minimumNumberOfTilesWide || divisorWidthIsPerfect;
        bool divisorHeightIsValid = divisor.second >= minimumNumberOfTilesHigh || divisorHeightIsPerfect;
        if (!divisorWidthIsValid || !divisorHeightIsValid)
            continue;

        if (divisor.first > divisor.second && direction == BackingStorePrivate::Vertical && !divisorHeightIsPerfect)
            continue;

        if (divisor.second > divisor.first && direction == BackingStorePrivate::Horizontal && !divisorWidthIsPerfect)
            continue;

        if (divisorWidthIsPerfect || divisorHeightIsPerfect) {
            bestDivisor = divisor; // Found a perfect fit!
#if DEBUG_TILEMATRIX
            Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "bestDivisor found perfect size widthPerfect=%s heightPerfect=%s",
                                   divisorWidthIsPerfect ? "true" : "false",
                                   divisorHeightIsPerfect ? "true" : "false");
#endif
            break;
        }

        // Store basis of comparison
        if (!bestDivisor.first && !bestDivisor.second) {
            bestDivisor = divisor;
            continue;
        }

        // Compare ratios
        float diff1 = fabs((static_cast<float>(divisor.first) / static_cast<float>(divisor.second)) - ratio);
        float diff2 = fabs((static_cast<float>(bestDivisor.first) / static_cast<float>(bestDivisor.second)) - ratio);
        if (diff1 < diff2)
            bestDivisor = divisor;
    }

    return bestDivisor;
}

BackingStorePrivate::BackingStorePrivate()
    : m_suspendScreenUpdates(false)
    , m_suspendOnIdle(false)
    , m_webPage(0)
    , m_renderQueue(new RenderQueue(this))
    , m_eglDisplay(EGL_NO_DISPLAY)
    , m_numberOfTilesWide(0)
    , m_numberOfTilesHigh(0)
    , m_preferredTileMatrixDimension(Vertical)
{
#if ENABLE_SCROLLBARS
    m_autoHideScrollbarsTimer = new Timer<BackingStorePrivate>(this, &BackingStorePrivate::autoHideScrollbars);
#endif
#if !ENABLE_REPAINTONSCROLL
    m_resumeRenderQueueTimer = new Timer<BackingStorePrivate>(this, &BackingStorePrivate::resumeRenderQueue);
#endif
}

BackingStorePrivate::~BackingStorePrivate()
{
    delete m_renderQueue;
    m_renderQueue = 0;
#if ENABLE_SCROLLBARS
    delete m_autoHideScrollbarsTimer;
    m_autoHideScrollbarsTimer = 0;
#endif
#if !ENABLE_REPAINTONSCROLL
    delete m_resumeRenderQueueTimer;
    m_resumeRenderQueueTimer = 0;
#endif
}

void BackingStorePrivate::suspendScreenUpdates()
{
    m_suspendScreenUpdates = true;
}

void BackingStorePrivate::resumeScreenUpdates(ResumeUpdateOperation op)
{
    m_suspendScreenUpdates = false;
    switch (op) {
    case Render:
        renderVisibleContents(true /*renderContentOnly*/);
        break;
    case Blit:
        {
            IntRect updateRect = blitVisibleContents();
            invalidateWindow(updateRect);
            break;
        }
    case RenderAndBlit:
        renderVisibleContents(false /*renderContentOnly*/);
        break;
    case None:
    default:
        break;
    }
}

void BackingStorePrivate::repaint(const WebCore::IntRect& windowRect,
                                  bool contentChanged, bool immediate, bool repaintContentOnly)
{
    ASSERT(m_eglDisplay != EGL_NO_DISPLAY);

    if (m_suspendScreenUpdates)
        return;

    /*
     * If immediate is true, then we're being asked to perform synchronously
     * If repaintContentOnly, then we're being asked to just render to the backingstore, but not to update the screen
     *
     * NOTE: WebCore::ScrollView will call this method with immediate:true and contentChanged:false.
     * This is a special case introduced specifically for the Apple's windows port and can be safely ignored I believe.
     *
     * Now this method will be called from WebPagePrivate::repaint()
     */

    if (contentChanged && !windowRect.isEmpty()) {
        // This windowRect is in untransformed coordinates relative to the viewport, but
        // it needs to be transformed coordinates relative to the transformed contents.
        IntRect rect = m_webPage->d->mapToTransformed(m_webPage->d->mapFromViewportToContents(windowRect));
        rect.inflate(1); // account for anti-aliasing of previous rendering runs
        m_webPage->d->clipToTransformedContentsRect(rect);

        if (immediate)
            render(rect, repaintContentOnly);
        else {
            // If we are currently loading, then intersect with only the visible
            // tiles as the rest is going to be invalidated once the load is finished
            // anyway, or will be invalidated if the users scrolls during the load
            if (m_webPage->d->loadState() == WebPagePrivate::Committed)
                rect.intersect(visibleTilesRect());

            // Map the rect along the render rect boundaries
            IntRectList rectList = mapFromTransformedContentsToRenderRectList(rect);
            if (rectList.isEmpty())
                return;

            for (size_t i = 0; i < rectList.size(); ++i)
                m_renderQueue->addToQueue(RenderQueue::RegularRender, rectList.at(i), repaintContentOnly);
        }
    }
}

void BackingStorePrivate::slowScroll(const WebCore::IntSize& delta, const WebCore::IntRect& windowRect, bool immediate)
{
#if DEBUG_BACKINGSTORE
    // Start the time measurement...
    double time = WTF::currentTime();
#endif

    if (!m_suspendScreenUpdates) {
#if ENABLE_SCROLLBARS
        if (m_webPage->settings()->isScrollbarsEnabled()) {
            // Restart the auto hide scrollbars timer
            m_autoHideScrollbarsTimer->stop();
            m_autoHideScrollbarsTimer->startOneShot(0.25);
        }
#endif

#if !ENABLE_REPAINTONSCROLL
        // Restart the resume render queue timer
        m_resumeRenderQueueTimer->stop();
        m_resumeRenderQueueTimer->startOneShot(0.05);

        // Suspend the onIdle rendering
        m_suspendOnIdle = true;
#endif
    }

    // Notify the render queue so that it can shuffle accordingly
    m_renderQueue->visibleContentChanged(visibleContentsRect());

    // Scroll the actual backingstore
    scrollBackingStore(delta.width(), delta.height());

    // Add any newly visible tiles that have not been previously rendered to the queue
    updateVisibleTilesForScroll();

    // This windowRect is in untransformed coordinates relative to the viewport, but
    // it needs to be transformed coordinates relative to the transformed contents.
    IntRect rect = m_webPage->d->mapToTransformed(m_webPage->d->mapFromViewportToContents(windowRect));
    m_webPage->d->clipToTransformedContentsRect(rect);

    m_renderQueue->addToQueue(RenderQueue::VisibleScroll, rect, true /*repaintContentOnly*/);

    // Blit the current contents to the canvas
    blitVisibleContents();

    // FIXME: Need to invalidate the window if *and only if* the scroll did not
    // originate with a window event!

#if DEBUG_BACKINGSTORE
    // Stop the time measurement
    double elapsed = WTF::currentTime() - time;
    Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "BackingStorePrivate::slowScroll elapsed=%f", elapsed);
#endif
}

void BackingStorePrivate::scroll(const WebCore::IntSize& delta,
                                 const WebCore::IntRect& scrollViewRect,
                                 const WebCore::IntRect& clipRect)
{
#if DEBUG_BACKINGSTORE
    // Start the time measurement...
    double time = WTF::currentTime();
#endif

    if (!m_suspendScreenUpdates) {
#if ENABLE_SCROLLBARS
        if (m_webPage->settings()->isScrollbarsEnabled()) {
            // Restart the auto hide scrollbars timer
            m_autoHideScrollbarsTimer->stop();
            m_autoHideScrollbarsTimer->startOneShot(0.25);
        }
#endif

#if !ENABLE_REPAINTONSCROLL
        // Restart the resume render queue timer
        m_resumeRenderQueueTimer->stop();
        m_resumeRenderQueueTimer->startOneShot(0.05);

        // Suspend the onIdle rendering
        m_suspendOnIdle = true;
#endif
    }

    // Notify the render queue so that it can shuffle accordingly
    m_renderQueue->updateSortDirection(delta.width(), delta.height());
    m_renderQueue->visibleContentChanged(visibleContentsRect());

    // Scroll the actual backingstore
    scrollBackingStore(delta.width(), delta.height());

    // Add any newly visible tiles that have not been previously rendered to the queue
    updateVisibleTilesForScroll();

    // Blit the current contents to the canvas
    blitVisibleContents();

    // FIXME: Need to invalidate the window if *and only if* the scroll did not
    // originate with a window event!

#if DEBUG_BACKINGSTORE
    // Stop the time measurement
    double elapsed = WTF::currentTime() - time;
    Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "BackingStorePrivate::scroll dx=%d, dy=%d elapsed=%f", delta.width(), delta.height(), elapsed);
#endif
}

bool BackingStorePrivate::hasIdleJobs() const
{
    return !m_suspendOnIdle && !m_suspendScreenUpdates && !m_renderQueue->isEmpty();
}

void BackingStorePrivate::renderOnIdle()
{
    ASSERT(hasIdleJobs());

    m_renderQueue->render();
}

bool BackingStorePrivate::willFireTimer()
{
    static const double s_minRenderInterval = 0.03; // 30ms

    if (!hasIdleJobs() || m_renderQueue->elapsedSinceLastRender() < s_minRenderInterval)
        return true;

    // To protect painting being blocked by timers, let's perform one render job now.
    m_renderQueue->render();

    // Let the caller yield and reschedule the timer.
    return false;
}

void BackingStorePrivate::autoHideScrollbars(WebCore::Timer<BackingStorePrivate>*)
{
    // Blit the current contents to the canvas
    IntRect updateRect = blitVisibleContents();
    invalidateWindow(updateRect);
}

void BackingStorePrivate::resumeRenderQueue(WebCore::Timer<BackingStorePrivate>*)
{
#if !ENABLE_REPAINTONSCROLL
    m_suspendOnIdle = false;
#endif
}

WebCore::IntRect BackingStorePrivate::expandedContentsRect() const
{
    return IntRect(IntPoint(0,0), expandedContentsSize());
}

WebCore::IntRect BackingStorePrivate::visibleContentsRect() const
{
    return m_webPage->d->transformedVisibleContentsRect();
}

WebCore::IntRect BackingStorePrivate::backingStoreRect() const
{
    return IntRect(m_backingStoreOffset, backingStoreSize());
}

bool BackingStorePrivate::shouldMoveLeft(const WebCore::IntRect& backingStoreRect) const
{
    return canMoveX(backingStoreRect)
            && backingStoreRect.x() > visibleContentsRect().x()
            && backingStoreRect.x() > expandedContentsRect().x();
}

bool BackingStorePrivate::shouldMoveRight(const WebCore::IntRect& backingStoreRect) const
{
    return canMoveX(backingStoreRect)
            && backingStoreRect.right() < visibleContentsRect().right()
            && backingStoreRect.right() < expandedContentsRect().right();
}

bool BackingStorePrivate::shouldMoveUp(const WebCore::IntRect& backingStoreRect) const
{
    return canMoveY(backingStoreRect)
            && backingStoreRect.y() > visibleContentsRect().y()
            && backingStoreRect.y() > expandedContentsRect().y();
}

bool BackingStorePrivate::shouldMoveDown(const WebCore::IntRect& backingStoreRect) const
{
    return canMoveY(backingStoreRect)
            && backingStoreRect.bottom() < visibleContentsRect().bottom()
            && backingStoreRect.bottom() < expandedContentsRect().bottom();
}

bool BackingStorePrivate::canMoveX(const WebCore::IntRect& backingStoreRect) const
{
    return backingStoreRect.width() > visibleContentsRect().width();
}

bool BackingStorePrivate::canMoveY(const WebCore::IntRect& backingStoreRect) const
{
    return backingStoreRect.height() > visibleContentsRect().height();
}

bool BackingStorePrivate::canMoveLeft(const WebCore::IntRect& rect) const
{
    IntRect backingStoreRect = rect;
    IntRect visibleContentsRect = this->visibleContentsRect();
    IntRect contentsRect = this->expandedContentsRect();
    backingStoreRect.move(-tileWidth(), 0);
    return backingStoreRect.right() >= visibleContentsRect.right()
            && backingStoreRect.x() >= contentsRect.x();
}

bool BackingStorePrivate::canMoveRight(const WebCore::IntRect& rect) const
{
    IntRect backingStoreRect = rect;
    IntRect visibleContentsRect = this->visibleContentsRect();
    IntRect contentsRect = this->expandedContentsRect();
    backingStoreRect.move(tileWidth(), 0);
    return backingStoreRect.x() <= visibleContentsRect.x()
            && (backingStoreRect.right() <= contentsRect.right()
            || (backingStoreRect.right() - contentsRect.right()) < tileWidth());
}

bool BackingStorePrivate::canMoveUp(const WebCore::IntRect& rect) const
{
    IntRect backingStoreRect = rect;
    IntRect visibleContentsRect = this->visibleContentsRect();
    IntRect contentsRect = this->expandedContentsRect();
    backingStoreRect.move(0, -tileHeight());
    return backingStoreRect.bottom() >= visibleContentsRect.bottom()
            && backingStoreRect.y() >= contentsRect.y();
}

bool BackingStorePrivate::canMoveDown(const WebCore::IntRect& rect) const
{
    IntRect backingStoreRect = rect;
    IntRect visibleContentsRect = this->visibleContentsRect();
    IntRect contentsRect = this->expandedContentsRect();
    backingStoreRect.move(0, tileHeight());
    return backingStoreRect.y() <= visibleContentsRect.y()
            && (backingStoreRect.bottom() <= contentsRect.bottom()
            || (backingStoreRect.bottom() - contentsRect.bottom()) < tileHeight());
}

IntRect BackingStorePrivate::backingStoreRectForScroll(int deltaX, int deltaY, const IntRect& rect) const
{
    // The current rect
    IntRect backingStoreRect = rect;

    // Return to origin if need be
    if (!canMoveX(backingStoreRect) && backingStoreRect.x())
        backingStoreRect.setX(0);

    if (!canMoveY(backingStoreRect) && backingStoreRect.y())
        backingStoreRect.setY(0);

    // Move the rect left
    while (shouldMoveLeft(backingStoreRect) || (deltaX > 0 && canMoveLeft(backingStoreRect)))
        backingStoreRect.move(-tileWidth(), 0);

    // Move the rect right
    while (shouldMoveRight(backingStoreRect) || (deltaX < 0 && canMoveRight(backingStoreRect)))
        backingStoreRect.move(tileWidth(), 0);

    // Move the rect up
    while (shouldMoveUp(backingStoreRect) || (deltaY > 0 && canMoveUp(backingStoreRect)))
        backingStoreRect.move(0, -tileHeight());

    // Move the rect down
    while (shouldMoveDown(backingStoreRect) || (deltaY < 0 && canMoveDown(backingStoreRect)))
        backingStoreRect.move(0, tileHeight());

    return backingStoreRect;
}

void BackingStorePrivate::setBackingStoreRect(const WebCore::IntRect& backingStoreRect)
{
    if (!m_webPage->isVisible())
        return;

    // Record the current backingstore rect
    IntRect currentBackingStoreRect = this->backingStoreRect();

    if (backingStoreRect == currentBackingStoreRect)
        return;

#if DEBUG_TILEMATRIX
    Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "BackingStorePrivate::setBackingStoreRect changed from (%d,%d %dx%d) to (%d,%d %dx%d)",
                           currentBackingStoreRect.x(),
                           currentBackingStoreRect.y(),
                           currentBackingStoreRect.width(),
                           currentBackingStoreRect.height(),
                           backingStoreRect.x(),
                           backingStoreRect.y(),
                           backingStoreRect.width(),
                           backingStoreRect.height());
#endif

    // The list of indexes we need to fill
    TileIndexList indexesToFill = indexesForBackingStoreRect(backingStoreRect);

    ASSERT(indexesToFill.size() == m_tileMap.size());

    TileMap tiles; // our new tile map
    TileMap leftOverTiles; // tiles that are left over

    // Iterate through our current tile map and add tiles that are rendered with
    // our new backingstore rect
    TileMap::const_iterator end = m_tileMap.end();
    TileMap::const_iterator it = m_tileMap.begin();
    while (it != end) {
        TileIndex oldIndex = it->first;
        RefPtr<BackingStoreTile> tile = it->second;

        // Reset the old index
        resetTile(oldIndex, tile.get(), false /*resetBackground*/);

        // Origin of last committed render for tile in transformed content coordinates
        IntPoint origin = originOfLastRenderForTile(oldIndex, tile.get(), currentBackingStoreRect);

        // If the new backing store rect contains this origin, then insert the tile there
        // and mark it as no longer shifted.  Note: IntRect::contains checks for a 1x1 rect
        // below and to the right of the origin so it is correct usage here.
        if (backingStoreRect.contains(origin)) {
            TileIndex newIndex = indexOfTile(origin, backingStoreRect);

            // Mark as needing update
            if (!tile->isCompletelyRendered())
                updateTile(origin, false /*immediate*/);

            // Do some bookkeeping with shifting tiles...
            tile->clearShift();
            tile->setCommitted(true);
            size_t i = indexesToFill.find(newIndex);
            ASSERT(i != WTF::notFound);
            indexesToFill.remove(i);
            tiles.add(newIndex, tile);
        } else {
            // Store this tile and index so we can add it to the remaining left over spots...
            leftOverTiles.add(oldIndex, tile);
        }

        ++it;
    }

    ASSERT(indexesToFill.size() == leftOverTiles.size());
    TileMap::const_iterator leftOverTilesIterator = leftOverTiles.begin();

    // Iterate through the remaining indexes and fill them in with left over tiles
    for (size_t i = 0; i < indexesToFill.size(); ++i) {
        TileIndex oldIndex = leftOverTilesIterator->first;
        TileIndex newIndex = indexesToFill.at(i);
        RefPtr<BackingStoreTile> tile = leftOverTilesIterator->second;

        // Origin of last committed render for tile in transformed content coordinates
        IntPoint originOfOld = originOfLastRenderForTile(oldIndex, tile.get(), currentBackingStoreRect);
        // Origin of the new index for the new backingstore rect
        IntPoint originOfNew = originOfTile(newIndex, backingStoreRect);

        // Mark as needing update
        updateTile(originOfNew, false /*immediate*/);

        // Do some bookkeeping with shifting tiles...
        tile->clearShift();
        tile->setCommitted(false);
        tile->setHorizontalShift((originOfOld.x() - originOfNew.x()) / tileWidth());
        tile->setVerticalShift((originOfOld.y() - originOfNew.y()) / tileHeight());

        tiles.add(newIndex, tile);

        ++leftOverTilesIterator;
    }

    // Actually set state
    m_numberOfTilesWide = backingStoreRect.width() / tileWidth();
    m_numberOfTilesHigh = backingStoreRect.height() / tileHeight();
    m_backingStoreOffset = backingStoreRect.location();
    ASSERT(m_tileMap.size() == tiles.size());
    m_tileMap = tiles;
}

BackingStorePrivate::TileIndexList BackingStorePrivate::indexesForBackingStoreRect(const WebCore::IntRect& backingStoreRect) const
{
    TileIndexList indexes;
    int numberOfTilesWide = backingStoreRect.width() / tileWidth();
    int numberOfTilesHigh = backingStoreRect.height() / tileHeight();
    for (int y = 0; y < numberOfTilesHigh; ++y) {
        for (int x = 0; x < numberOfTilesWide; ++x) {
            TileIndex index(x, y);
            indexes.append(index);
        }
    }
    return indexes;
}

WebCore::IntPoint BackingStorePrivate::originOfLastRenderForTile(const TileIndex& index,
                                                                 BackingStoreTile* tile,
                                                                 const WebCore::IntRect& backingStoreRect) const
{
    return originOfTile(indexOfLastRenderForTile(index, tile), backingStoreRect);
}

TileIndex BackingStorePrivate::indexOfLastRenderForTile(const TileIndex& index, BackingStoreTile* tile) const
{
    return TileIndex(index.i() + tile->horizontalShift(), index.j() + tile->verticalShift());
}

TileIndex BackingStorePrivate::indexOfTile(const WebCore::IntPoint& origin,
                                           const WebCore::IntRect& backingStoreRect) const
{
    int offsetX = origin.x() - backingStoreRect.x();
    int offsetY = origin.y() - backingStoreRect.y();
    if (offsetX)
        offsetX = offsetX / tileWidth();
    if (offsetY)
        offsetY = offsetY / tileHeight();
    return TileIndex(offsetX, offsetY);
}

void BackingStorePrivate::scrollBackingStore(int deltaX, int deltaY)
{
    if (!m_webPage->isVisible())
        return;

    // Calculate our new preferred matrix dimension
    if (deltaX || deltaY)
        m_preferredTileMatrixDimension = abs(deltaX) > abs(deltaY) ? Horizontal : Vertical;

    // Calculate our preferred matrix geometry
    Divisor divisor = bestDivisor(expandedContentsSize(),
                                  tileWidth(), tileHeight(),
                                  minimumNumberOfTilesWide(), minimumNumberOfTilesHigh(),
                                  m_preferredTileMatrixDimension);

#if DEBUG_TILEMATRIX
    Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "BackingStorePrivate::scrollBackingStore divisor %dx%d",
                           divisor.first,
                           divisor.second);
#endif

    // Initialize a rect with that new geometry
    IntRect backingStoreRect(0, 0, divisor.first * tileWidth(), divisor.second * tileHeight());

    // Scroll that rect so that it fits our contents and viewport and scroll delta
    backingStoreRect = backingStoreRectForScroll(deltaX, deltaY, backingStoreRect);

    ASSERT(!backingStoreRect.isEmpty());

    // Set the state
    setBackingStoreRect(backingStoreRect);
}

void BackingStorePrivate::render(const WebCore::IntRectList& rectList, bool renderContentOnly)
{
    // FIXME: We cycle through one by one and only blit the contents at the end.
    // This can be improved upon if we had a mapFromTransformedContentsToTiles that
    // took a set of rects and decomposed them appropriately
    for (size_t i = 0; i < rectList.size(); ++i)
        render(rectList.at(i), true);

    if (!renderContentOnly) {
        IntRect updateRect = blitVisibleContents();
        invalidateWindow(updateRect);
    }
}

void BackingStorePrivate::render(const WebCore::IntRect& rect, bool renderContentOnly)
{
    if (!m_webPage->isVisible())
        return;

    TileRectList tileRectList = mapFromTransformedContentsToTiles(rect);
    if (tileRectList.isEmpty())
        return;

    IntRect screenRect;

    // Request a layout now which might change the contents rect
    requestLayoutIfNeeded();

    bool shouldBlit = !m_suspendScreenUpdates && !renderContentOnly;
    const IntRect contentsRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedContentsSize());
    const IntRect viewportRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedViewportSize());
    SurfaceOpenVG* renderingSurface = SurfacePool::globalSurfacePool()->tileRenderingSurface();

    for (size_t i = 0; i < tileRectList.size(); ++i) {
        TileRect tileRect = tileRectList[i];
        TileIndex index = tileRect.first;
        IntRect dirtyTileRect = tileRect.second;
        RefPtr<BackingStoreTile> tile = m_tileMap.get(index);

        // This dirty tile rect is in tile coordinates, but it needs to be in transformed contents coordinates
        IntRect dirtyRect = mapFromTilesToTransformedContents(tileRect);

        // If we're not yet committed, then commit now by clearing the rendered region
        // and setting the committed flag as well as clearing the shift
        if (!tile->isCommitted()) {
            tile->setCommitted(true);
            tile->clearRenderedRegion();
            tile->clearShift();
        }

        // If the tile has been created, but this is the first time we are painting on it
        // then it hasn't been given a default background yet so that we can save time during
        // startup.  That's why we are doing it here instead...
        if (!tile->backgroundPainted())
            tile->paintBackground();

        // Add the newly rendered region to the tile so it can keep track for blits
        tile->addRenderedRegion(dirtyTileRect);

        // Paint default background if contents rect is empty
        if (!contentsRect.isEmpty()) {
            // Otherwise we should clip the contents size and render the content
            dirtyRect.intersect(contentsRect);

            // We probably have extra tiles since the contents size is so small.  Save some cycles here...
            if (dirtyRect.isEmpty())
                continue;
        }

        // FIXME: modify render to take a Vector<IntRect> parameter so we're not recreating
        // GraphicsContext on the stack each time
        m_webPage->d->renderContents(renderingSurface, tile.get(), originOfTile(index), dirtyRect);

        // Now, this dirty rect is in transformed coordinates relative to the transformed contents, but
        // ultimately it needs to be transformed coordinates relative to the viewport.
        dirtyRect = m_webPage->d->mapFromTransformedContentsToTransformedViewport(dirtyRect);

        if (!shouldBlit)
            continue;

        IntRect dstRect = dirtyRect;
        IntRect srcRect = dirtyTileRect;

        // Clip to the viewport
        dstRect.intersect(viewportRect);

        // Clip to the visible content
        srcRect.intersect(tileVisibleContentsRect(index));

        m_webPage->client()->lockCanvas();
        m_webPage->d->blitToCanvas(tile->image(), tile->imageStride(), dstRect, srcRect);
        m_webPage->client()->unlockCanvas();
        screenRect.unite(dstRect);
    }

    if (!shouldBlit)
        return;

    m_webPage->d->invalidateWindow(screenRect);
}

void BackingStorePrivate::requestLayoutIfNeeded() const
{
    m_webPage->d->requestLayoutIfNeeded();
}

void BackingStorePrivate::renderVisibleContents(bool renderContentOnly)
{
    render(visibleTilesRect(), renderContentOnly);
}

void BackingStorePrivate::renderBackingStore(bool renderContentOnly)
{
    render(backingStoreRect(), renderContentOnly);
}

WebCore::IntRect BackingStorePrivate::blitVisibleContents()
{
    if (m_suspendScreenUpdates)
        return IntRect();

    if (!m_webPage->isVisible())
        return IntRect();

#if DEBUG_BACKINGSTORE
    Olympia::Platform::log(Olympia::Platform::LogLevelCritical, "BackingStorePrivate::blitVisibleContents");
#endif

    // Get the list of tile rects that makeup the visible content
    const IntRect contentsRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedContentsSize());
    const IntRect viewportRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedViewportSize());

    m_webPage->client()->lockCanvas();
    IntRect screenRect;
    TileRectList tileRectList = mapFromTransformedContentsToTiles(visibleContentsRect());
    for (size_t i = 0; i < tileRectList.size(); ++i) {
        TileRect tileRect = tileRectList[i];
        TileIndex index = tileRect.first;
        IntRect dirtyTileRect = tileRect.second;
        RefPtr<BackingStoreTile> tile = m_tileMap.get(index);

        // This dirty rect is in tile coordinates, but it needs to be in transformed contents coordinates
        IntRect dirtyRect = mapFromTilesToTransformedContents(tileRect);

        // Don't clip to contents if it is empty so we can still paint default background
        if (!contentsRect.isEmpty()) {
            // Otherwise we should clip the contents size and blit
            dirtyRect.intersect(contentsRect);

            // We probably have extra tiles since the contents size is so small.  Save some cycles here...
            if (dirtyRect.isEmpty())
                continue;
        }

        // Now, this dirty rect is in transformed coordinates relative to the transformed contents, but
        // ultimately it needs to be transformed coordinates relative to the viewport.
        dirtyRect = m_webPage->d->mapFromTransformedContentsToTransformedViewport(dirtyRect);

        // Clip to the viewport
        dirtyRect.intersect(viewportRect);

        // Clip to the visible content
        dirtyTileRect.intersect(tileVisibleContentsRect(index));

        // Save some cycles here...
        if (dirtyRect.isEmpty() || dirtyTileRect.isEmpty())
            continue;

        TileRect wholeTileRect;
        wholeTileRect.first = index;
        wholeTileRect.second = this->tileRect();
        IntRect wholeRect = mapFromTilesToTransformedContents(wholeTileRect);

        if (!tile->isCommitted() || !tile->isCompletelyRendered()) {
            // Blit the checkered pattern here
            RefPtr<BackingStoreTile> checkeredTile = SurfacePool::globalSurfacePool()->checkeredTile();
            m_webPage->d->blitToCanvas(checkeredTile->image(), tile->imageStride(),
                dirtyRect, dirtyTileRect);
        }

        // Blit the visible buffer here if we have visible zoom jobs
        if (m_renderQueue->hasCurrentVisibleZoomJob()) {

            // Needs to be in same coordinate system as dirtyRect
            IntRect visibleTileBufferRect = m_webPage->d->mapFromTransformedContentsToTransformedViewport(m_visibleTileBufferRect);

            // Clip to the viewport
            visibleTileBufferRect.intersect(viewportRect);

            // Clip to the visibleTileBufferRect
            dirtyRect.intersect(visibleTileBufferRect);

            // Clip to the dirtyRect
            visibleTileBufferRect.intersect(dirtyRect);

            if (!dirtyRect.isEmpty() && !visibleTileBufferRect.isEmpty()) {
                BackingStoreTile* visibleTileBuffer = SurfacePool::globalSurfacePool()->visibleTileBuffer();
                ASSERT(visibleTileBuffer->size() == visibleContentsRect().size());

                // The offset of the current viewport with the visble tile buffer
                IntSize offset = visibleContentsRect().location() - m_visibleTileBufferRect.location();

                // Map to the visibleTileBuffer coordinates
                IntRect dirtyTileRect = visibleTileBufferRect;
                dirtyTileRect.move(offset);

                m_webPage->d->blitToCanvas(visibleTileBuffer->image(), visibleTileBuffer->imageStride(),
                    dirtyRect, dirtyTileRect);
            }
        } else if (tile->isCommitted()) {
            // Intersect the rendered region
            IntRectRegion renderedRegion = tile->renderedRegion();
            Vector<IntRect> dirtyRenderedRects = renderedRegion.rects();
            for (size_t i = 0; i < dirtyRenderedRects.size(); ++i) {
                TileRect tileRect;
                tileRect.first = index;
                tileRect.second = intersection(dirtyTileRect, dirtyRenderedRects.at(i));
                if (tileRect.second.isEmpty())
                    continue;
                // Blit the rendered parts
                screenRect.unite(blitTileRect(tileRect));
            }
        } else {
            // Either the visual tiles for scroll are outdated or this tile should have been committed.
            ASSERT(m_renderQueue->isCurrentVisibleScrollJob(wholeRect) || m_renderQueue->isCurrentVisibleScrollJobCompleted(wholeRect));
        }
    }

#if ENABLE_SCROLLBARS
    if (m_autoHideScrollbarsTimer->isActive()) {
        if (scrollsHorizontally())
            blitHorizontalScrollbar();
        if (scrollsVertically())
            blitVerticalScrollbar();
    }
#endif

    m_webPage->client()->unlockCanvas();

    return screenRect;
}

WebCore::IntRect BackingStorePrivate::blitTileRect(const TileRect& tileRect)
{
    if (!m_webPage->isVisible())
        return IntRect();

    TileIndex index = tileRect.first;
    IntRect dirtyTileRect = tileRect.second;
    RefPtr<BackingStoreTile> tile = m_tileMap.get(index);

    // This dirty rect is in tile coordinates, but it needs to be in transformed contents coordinates
    IntRect dirtyRect = mapFromTilesToTransformedContents(tileRect);

    // Now, this dirty rect is in transformed coordinates relative to the transformed contents, but
    // ultimately it needs to be transformed coordinates relative to the viewport.
    dirtyRect = m_webPage->d->mapFromTransformedContentsToTransformedViewport(dirtyRect);

    ASSERT(!dirtyRect.isEmpty());
    ASSERT(!dirtyTileRect.isEmpty());
    if (dirtyRect.isEmpty() || dirtyTileRect.isEmpty())
        return IntRect();

    m_webPage->d->blitToCanvas(tile->image(), tile->imageStride(),
        dirtyRect, dirtyTileRect);
    return dirtyRect;
}

void BackingStorePrivate::invalidateWindow(const WebCore::IntRect& screenRect)
{
    m_webPage->d->invalidateWindow(screenRect);
}

bool BackingStorePrivate::scrollsHorizontally() const
{
    return m_webPage->d->transformedActualVisibleSize().width() < m_webPage->d->transformedContentsSize().width();
}

bool BackingStorePrivate::scrollsVertically() const
{
    return m_webPage->d->transformedActualVisibleSize().height() < m_webPage->d->transformedContentsSize().height();
}

// The extent of the top of the scrollbar to the bottom of the screen
float BackingStorePrivate::horizontalScrollbarExtent() const
{
    if (!m_webPage->isVisible()) {
        ASSERT_NOT_REACHED();
        return 0.0;
    }

    if (!scrollsHorizontally())
        return 0.0;

    FloatRect scrollbarRect = SurfacePool::globalSurfacePool()->horizontalScrollbar()->rect();
    scrollbarRect.inflateY(-1.5);
    ASSERT(scrollbarRect.height() >= 0);

    return scrollbarRect.height();
}

// The extent of the left of the scrollbar to the right of the screen
float BackingStorePrivate::verticalScrollbarExtent() const
{
    if (!m_webPage->isVisible()) {
        ASSERT_NOT_REACHED();
        return 0.0;
    }

    if (!scrollsVertically())
        return 0.0;

    FloatRect scrollbarRect = SurfacePool::globalSurfacePool()->verticalScrollbar()->rect();
    scrollbarRect.inflateX(-1.5);
    return scrollbarRect.width();
}

void BackingStorePrivate::blitHorizontalScrollbar()
{
    if (!m_webPage->isVisible())
        return;

    ASSERT(scrollsHorizontally());
    IntRect scrollbarRect = SurfacePool::globalSurfacePool()->horizontalScrollbar()->rect();
    IntRect canvasRect = scrollbarRect;
    IntSize visibleSize = m_webPage->d->transformedActualVisibleSize();
    canvasRect.move(0, visibleSize.height() - scrollbarRect.height());

    float verticalScrollbarExtent = this->verticalScrollbarExtent();

    float widthScale = static_cast<float>(visibleSize.width() - verticalScrollbarExtent)
                            / static_cast<float>(m_webPage->d->transformedContentsSize().width());
    float xScale = static_cast<float>(m_webPage->d->transformedScrollPosition().x())
                       / static_cast<float>(m_webPage->d->transformedMaximumScrollPosition().x());
    float width = static_cast<float>(scrollbarRect.width() - verticalScrollbarExtent) * widthScale;
    float x = (static_cast<float>(scrollbarRect.width() - verticalScrollbarExtent) - width) * xScale;

    IntRect hotRect = IntRect(roundf(x), 0, roundf(width), scrollbarRect.height());

    ASSERT(hotRect.width() >= 0 && hotRect.height() >= 0);

    hotRect.inflateY(-1);
    hotRect.inflateX(-1);

    // Don't draw scrollbars if they'll be 0-dimensional anyhow.
    if (hotRect.width() <= 0 || hotRect.height() <= 0)
        return;


    SurfacePool::globalSurfacePool()->horizontalScrollbar()->repaint(hotRect, false /*vertical*/);

    BackingStoreScrollbar* scrollbar = SurfacePool::globalSurfacePool()->horizontalScrollbar();
    m_webPage->d->blendOntoCanvas(scrollbar->image(), scrollbar->imageStride(),
        scrollbar->alphaImage(), scrollbar->alphaImageStride(), 255, canvasRect, scrollbarRect);
}

void BackingStorePrivate::blitVerticalScrollbar()
{
    if (!m_webPage->isVisible())
        return;

    ASSERT(scrollsVertically());
    IntRect scrollbarRect = SurfacePool::globalSurfacePool()->verticalScrollbar()->rect();
    IntRect canvasRect = scrollbarRect;
    IntSize visibleSize = m_webPage->d->transformedActualVisibleSize();
    canvasRect.move(visibleSize.width() - scrollbarRect.width(), 0);

    float horizontalScrollbarExtent = this->horizontalScrollbarExtent();

    float heightScale = static_cast<float>(visibleSize.height() - horizontalScrollbarExtent)
                            / static_cast<float>(m_webPage->d->transformedContentsSize().height());
    float yScale = static_cast<float>(m_webPage->d->transformedScrollPosition().y())
                       / static_cast<float>(m_webPage->d->transformedMaximumScrollPosition().y());
    float height = static_cast<float>(scrollbarRect.height() - horizontalScrollbarExtent) * heightScale;
    float y = (static_cast<float>(scrollbarRect.height() - horizontalScrollbarExtent) - height) * yScale;

    IntRect hotRect = IntRect(0, roundf(y), scrollbarRect.width(), roundf(height));

    ASSERT(hotRect.width() >= 0 && hotRect.height() >= 0);

    hotRect.inflateX(-1);
    hotRect.inflateY(-1);

    // Don't draw scrollbars if they'll be 0-dimensional anyhow.
    if (hotRect.width() <= 0 || hotRect.height() <= 0)
        return;

    SurfacePool::globalSurfacePool()->verticalScrollbar()->repaint(hotRect, true /*vertical*/);

    BackingStoreScrollbar* scrollbar = SurfacePool::globalSurfacePool()->verticalScrollbar();
    m_webPage->d->blendOntoCanvas(scrollbar->image(), scrollbar->imageStride(),
        scrollbar->alphaImage(), scrollbar->alphaImageStride(), 255, canvasRect, scrollbarRect);
}

void BackingStorePrivate::blitScaledArbitraryRectFromBackingStoreToScreen(const WebCore::IntRect& srcRect, WebCore::IntRect dstRect, SurfaceOpenVG* tempSurface)
{
    ASSERT(tempSurface);

    if (!m_webPage->isVisible())
        return;

    const IntRect contentsRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedContentsSize());

    TransformationMatrix transformation = TransformationMatrix::rectToRect(
        FloatRect(FloatPoint(0.0, 0.0), srcRect.size()), dstRect);
    transformation.translate(-srcRect.x(), -srcRect.y());

    IntRect srcRectTransformed = transformation.mapRect(srcRect);

    const IntRect viewportRect = IntRect(IntPoint(0, 0), m_webPage->d->transformedViewportSize());

    tempSurface->makeCurrent();

    // Paint gray background for non-page area.
    const VGfloat gray[4] = { 0.5, 0.5, 0.5, 1.0 };
    vgSeti(VG_SCISSORING, VG_FALSE);
    vgSetfv(VG_CLEAR_COLOR, 4, gray);
    vgClear(0, 0, dstRect.width(), dstRect.height());

    // Paint checkerboard for non-drawn page areas.
    IntRect checkerRect = srcRect;
    checkerRect.intersect(contentsRect);
    checkerRect = transformation.mapRect(checkerRect);
    checkerRect.intersect(viewportRect);

    if (!checkerRect.isEmpty()) {
        // Tile the checker tile into the image to ensure that we have full
        // coverage. In the case where tiles are portrait screen size, this
        // isn't too bad. It results in only one extra copy for landscape mode.
        // But this should be replaced with something more efficient in the
        // future in case backingstore tiles change size.
        BackingStoreTile* checkeredTile = SurfacePool::globalSurfacePool()->checkeredTile();
        IntSize checkerTileSize = checkeredTile->size();

        int firstXTile = checkerRect.x() / checkerTileSize.width();
        int firstYTile = checkerRect.y() / checkerTileSize.height();
        int lastXTile = (checkerRect.right() - 1) / checkerTileSize.width();
        int lastYTile = (checkerRect.bottom() - 1) / checkerTileSize.height();

        for (int i = firstXTile; i <= lastXTile; ++i) {
            for (int j = firstYTile; j <= lastYTile; ++j) {
                const int dstX = (i == firstXTile) ? checkerRect.x() : i * checkerTileSize.width();
                const int dstY = (j == firstYTile) ? checkerRect.y() : j * checkerTileSize.height();
                const int dstRight = (i == lastXTile) ? checkerRect.right() : (i + 1) * checkerTileSize.width();
                const int dstBottom = (i == lastYTile) ? checkerRect.bottom() : (j + 1) * checkerTileSize.height();
                const int srcX = dstX % checkerTileSize.width();
                const int srcY = dstY % checkerTileSize.height();
                const unsigned char* srcBufferStart = checkeredTile->image() +
                    (srcY * checkeredTile->imageStride()) + (srcX * checkeredTile->imageBytesPerPixel());

                vgWritePixels(srcBufferStart, checkeredTile->imageStride(), VG_sRGB_565,
                    dstX, dstY, dstRight - dstX, dstBottom - dstY);
            }
        }
        ASSERT_VG_NO_ERROR();
    }

    TileRectList tileRectList = mapFromTransformedContentsToTiles(srcRect);
    PainterOpenVG p(tempSurface);

    const IntSize vgMaxImageSize(vgGeti(VG_MAX_IMAGE_WIDTH), vgGeti(VG_MAX_IMAGE_HEIGHT));

    for (size_t i = 0; i < tileRectList.size(); ++i) {
        TileRect tileRect = tileRectList[i];
        TileIndex index = tileRect.first;
        IntRect dirtyTileRect = tileRect.second;
        RefPtr<BackingStoreTile> tile = m_tileMap.get(index);

        if (!tile->isCompletelyRendered())
            continue;

        // Compose part of temp surface represented by this dirty rect.
        IntRect rect = intersection(dirtyTileRect, IntRect(0, 0, tile->size().width(), tile->size().height()));

        // Clip the src tile rect to the actually rendered portion of the tile
        IntPoint originOfTile = this->originOfTile(index);
        IntPoint oldOrigin = rect.topLeft();
        rect.move(originOfTile.x(), originOfTile.y());
        rect.intersect(contentsRect);
        rect.setLocation(oldOrigin);

        if (rect.isEmpty())
            continue;

        TiledImageOpenVG tiledImage(rect.size(), vgMaxImageSize);

        const int numColumns = tiledImage.numColumns();
        const int numRows = tiledImage.numRows();

        // Create a TiledImage from the dirty rect of the current surface.
        for (int yIndex = 0; yIndex < numRows; ++yIndex) {
            for (int xIndex = 0; xIndex < numColumns; ++xIndex) {
                IntRect tRect = tiledImage.tileRect(xIndex, yIndex);
                VGImage image = vgCreateImage(VG_sARGB_8888_PRE, tRect.width(), tRect.height(), VG_IMAGE_QUALITY_FASTER);
                ASSERT_VG_NO_ERROR();

                const int srcX = rect.x() + tRect.x();
                const int srcY = rect.y() + tRect.y();
                const unsigned char* srcBufferStart = tile->image() + (srcY * tile->imageStride()) + (srcX * tile->imageBytesPerPixel());
                vgImageSubData(image, srcBufferStart, tile->imageStride(), VG_sRGB_565, 0, 0, tRect.width(), tRect.height());
                ASSERT_VG_NO_ERROR();
                tiledImage.setTile(xIndex, yIndex, image);
            }
        }

        // Copy the image to the temp surface.
        IntRect dirtyRect = mapFromTilesToTransformedContents(tileRect);
        dirtyRect.intersect(contentsRect);
        dirtyRect = transformation.mapRect(dirtyRect);

        // Stretch-blit image to temp surface.
        p.drawImage(&tiledImage, dirtyRect, IntRect(0, 0, rect.width(), rect.height()));
    }

    dstRect.intersect(viewportRect);

    // blit temp surface to canvas
    m_webPage->client()->lockCanvas();
    m_webPage->d->blitToCanvas(tempSurface, dstRect, IntRect(0, 0, dstRect.width(), dstRect.height()));
    m_webPage->client()->unlockCanvas();
    m_webPage->d->invalidateWindow(dstRect);
}


bool BackingStorePrivate::isTileVisible(const TileIndex& index) const
{
    TileRect tileRect;
    tileRect.first = index;
    tileRect.second = this->tileRect();
    return mapFromTilesToTransformedContents(tileRect).intersects(visibleContentsRect());
}

bool BackingStorePrivate::isTileVisible(const WebCore::IntPoint& origin) const
{
    return IntRect(origin, tileSize()).intersects(visibleContentsRect());
}

WebCore::IntRect BackingStorePrivate::visibleTilesRect() const
{
    IntRect rect;
    TileMap::const_iterator end = m_tileMap.end();
    for (TileMap::const_iterator it = m_tileMap.begin(); it != end; ++it) {
        TileRect tileRect;
        tileRect.first = it->first;
        tileRect.second = this->tileRect();
        IntRect tile = mapFromTilesToTransformedContents(tileRect);
        if (tile.intersects(visibleContentsRect()))
            rect.unite(tile);
    }
    return rect;
}

WebCore::IntRect BackingStorePrivate::tileVisibleContentsRect(const TileIndex& index) const
{
    if (!isTileVisible(index))
        return IntRect();

    TileRectList tileRectList = mapFromTransformedContentsToTiles(visibleContentsRect());
    for (size_t i = 0; i < tileRectList.size(); ++i) {
        TileRect tileRect = tileRectList[i];
        if (index == tileRect.first)
            return tileRect.second;
    }
    return IntRect();
}

void BackingStorePrivate::clearRenderQueue()
{
    m_renderQueue->clear();
}

void BackingStorePrivate::clearVisibleZoom()
{
    m_renderQueue->clearVisibleZoom();
}

void BackingStorePrivate::resetTiles(bool resetBackground)
{
    TileMap::const_iterator end = m_tileMap.end();
    for (TileMap::const_iterator it = m_tileMap.begin(); it != end; ++it)
        resetTile(it->first, it->second.get(), resetBackground);
}

void BackingStorePrivate::updateTiles(bool updateVisible, bool immediate)
{
    TileMap::const_iterator end = m_tileMap.end();
    for (TileMap::const_iterator it = m_tileMap.begin(); it != end; ++it) {
        bool isVisible = isTileVisible(it->first);
        if (!updateVisible && isVisible)
            continue;
        updateTile(it->first, immediate);
    }
}

void BackingStorePrivate::updateVisibleTilesForScroll()
{
    bool checkRendered = m_webPage->d->loadState() != WebPagePrivate::Committed;
    TileMap::const_iterator end = m_tileMap.end();
    for (TileMap::const_iterator it = m_tileMap.begin(); it != end; ++it) {
        TileRect tileRect;
        tileRect.first = it->first;
        tileRect.second = this->tileRect();
        if (isTileVisible(it->first)
            && (!checkRendered || !it->second->isCompletelyRendered())
            && !m_renderQueue->isCurrentVisibleScrollJob(mapFromTilesToTransformedContents(tileRect)))
            updateTile(it->first, false /*immediate*/);
    }
}

void BackingStorePrivate::resetTile(const TileIndex& index, BackingStoreTile* tile, bool resetBackground)
{
    if (!m_webPage->isVisible())
        return;

    TileRect tileRect;
    tileRect.first = index;
    tileRect.second = this->tileRect();
    m_renderQueue->clear(mapFromTilesToTransformedContents(tileRect));
    if (resetBackground)
        tile->reset();
}

void BackingStorePrivate::updateTile(const TileIndex& index, bool immediate)
{
    TileRect tileRect;
    tileRect.first = index;
    tileRect.second = this->tileRect();
    IntRect updateRect = mapFromTilesToTransformedContents(tileRect);
    RenderQueue::JobType jobType = isTileVisible(index) ? RenderQueue::VisibleScroll : RenderQueue::NonVisibleScroll;
    if (immediate)
        render(updateRect, true /*renderContentOnly*/);
    else
        m_renderQueue->addToQueue(jobType, updateRect, true /*renderContentOnly*/);
}

void BackingStorePrivate::updateTile(const WebCore::IntPoint& origin, bool immediate)
{
    IntRect updateRect = IntRect(origin, tileSize());
    RenderQueue::JobType jobType = isTileVisible(origin) ? RenderQueue::VisibleScroll : RenderQueue::NonVisibleScroll;
    if (immediate)
        render(updateRect, true /*renderContentOnly*/);
    else
        m_renderQueue->addToQueue(jobType, updateRect, true /*renderContentOnly*/);
}

WebCore::IntRect BackingStorePrivate::mapFromTilesToTransformedContents(const BackingStorePrivate::TileRect& tileRect) const
{
    TileIndex index = tileRect.first;
    IntRect rect = tileRect.second;
    // The origin of the tile including the backing store offset
    const IntPoint originOfTile = this->originOfTile(index);
    rect.move(originOfTile.x(), originOfTile.y());
    return rect;
}

BackingStorePrivate::TileRectList BackingStorePrivate::mapFromTransformedContentsToTiles(const WebCore::IntRect& rect) const
{
    if (!m_webPage->isVisible()) {
        ASSERT_NOT_REACHED();
        return TileRectList();
    }

    TileRectList tileRectList;
    TileMap::const_iterator end = m_tileMap.end();
    for (TileMap::const_iterator it = m_tileMap.begin(); it != end; ++it) {
        TileIndex index = it->first;
        RefPtr<BackingStoreTile> tile = it->second;

        // Need to map the rect to tile coordinates
        IntRect r = rect;

        // The origin of the tile including the backing store offset
        const IntPoint originOfTile = this->originOfTile(index);

        r.move(-(originOfTile.x()), -(originOfTile.y()));

        // Do we intersect the current tile or no?
        r.intersect(tile->rect());
        if (r.isEmpty())
            continue;

        // If we do append to list and Voila!
        TileRect tileRect;
        tileRect.first = index;
        tileRect.second = r;
        tileRectList.append(tileRect);
    }
    return tileRectList;
}

WebCore::IntRectList BackingStorePrivate::mapFromTransformedContentsToRenderRectList(const WebCore::IntRect& rect) const
{
    return m_renderQueue->convertToRenderRectList(rect);
}

void BackingStorePrivate::updateTileMatrixIfNeeded()
{
    // This will update the tile matrix
    scrollBackingStore(0, 0);
}

void BackingStorePrivate::contentsSizeChanged(const WebCore::IntSize&)
{
    updateTileMatrixIfNeeded();
}

void BackingStorePrivate::scrollChanged(const IntPoint&)
{
    // FIXME: Need to do anything here?
}

void BackingStorePrivate::transformChanged()
{
    if (!m_webPage->isVisible())
        return;

    bool hasCurrentVisibleZoomJob = m_renderQueue->hasCurrentVisibleZoomJob();
    bool isLoading = m_webPage->d->loadState() == WebPagePrivate::Provisional || m_webPage->d->loadState() == WebPagePrivate::Committed;
    if (isLoading) {
        if (!hasCurrentVisibleZoomJob)
            m_visibleTileBufferRect = visibleContentsRect(); // cache this for blitVisibleContents

        // Add the currently visible tiles to the render queue as visible zoom jobs
        TileRectList tileRectList = mapFromTransformedContentsToTiles(visibleContentsRect());
        for (size_t i = 0; i < tileRectList.size(); ++i) {
            TileRect tileRect = tileRectList[i];
            TileIndex index = tileRect.first;
            IntRect dirtyTileRect = tileRect.second;
            RefPtr<BackingStoreTile> tile = m_tileMap.get(index);

            // Invalidate the whole rect
            tileRect.second = this->tileRect();
            IntRect wholeRect = mapFromTilesToTransformedContents(tileRect);
            m_renderQueue->addToQueue(RenderQueue::VisibleZoom, wholeRect, true /*renderContentOnly*/);

            // Copy the visible contents into the visibleTileBuffer if we don't have any current visible zoom jobs
            if (!hasCurrentVisibleZoomJob) {
                // Map to the destination's coordinate system
                IntSize offset = this->originOfTile(index) - m_visibleTileBufferRect.location();
                IntRect dirtyRect = dirtyTileRect;
                dirtyRect.move(offset);

                BackingStoreTile* visibleTileBuffer = SurfacePool::globalSurfacePool()->visibleTileBuffer();
                ASSERT(visibleTileBuffer->size() == visibleContentsRect().size());
                m_webPage->d->blitFromBufferToBuffer(visibleTileBuffer->image(), visibleTileBuffer->imageStride(), dirtyRect,
                                                     tile->image(), tile->imageStride(), dirtyTileRect);
            }
        }
    }

    resetTiles(true /*resetBackground*/);
}

void BackingStorePrivate::orientationChanged()
{
    updateTileMatrixIfNeeded();
    createVisibleTileBuffer();
}

void BackingStorePrivate::actualVisibleSizeChanged(const WebCore::IntSize& size)
{
#if ENABLE_SCROLLBARS
    if (!SurfacePool::globalSurfacePool()->horizontalScrollbar())
        return;

    if (!SurfacePool::globalSurfacePool()->verticalScrollbar())
        return;

    createScrollbars();

    if (m_webPage->settings()->isScrollbarsEnabled()) {
        // Restart the auto hide scrollbars timer
        m_autoHideScrollbarsTimer->stop();
        m_autoHideScrollbarsTimer->startOneShot(0.25);
    }

    // This only occurs with a window event, thus the window does not need to be
    // invalidated, rather just copy the visible contents to the current canvas
    // in order to show the scrollbars.
    blitVisibleContents();
#endif
}

void BackingStorePrivate::createSurfaces()
{
    ASSERT(m_tileMap.isEmpty());

    if (!m_webPage->isVisible()) {
        ASSERT_NOT_REACHED();
        return;
    }

    SurfacePool* surfacePool = SurfacePool::globalSurfacePool();
    if (surfacePool->isEmpty())
        surfacePool->initialize(tileSize());

    const Divisor divisor = bestDivisor(expandedContentsSize(), tileWidth(), tileHeight(), minimumNumberOfTilesWide(), minimumNumberOfTilesHigh(), m_preferredTileMatrixDimension);
    m_numberOfTilesWide = divisor.first;
    m_numberOfTilesHigh = divisor.second;

    const SurfacePool::TileList tileList = surfacePool->tileList();
    ASSERT(tileList.size() >= (m_numberOfTilesWide * m_numberOfTilesHigh));

    for (int y = 0; y < m_numberOfTilesHigh; ++y) {
        for (int x = 0; x < m_numberOfTilesWide; ++x) {
            TileIndex index(x, y);
            m_tileMap.add(index, tileList.at(x + y * m_numberOfTilesWide));
        }
    }

    createVisibleTileBuffer();
#if ENABLE_SCROLLBARS
    createScrollbars();
#endif
}

void BackingStorePrivate::createVisibleTileBuffer()
{
    if (!m_webPage->isVisible())
        return;

    SurfacePool* surfacePool = SurfacePool::globalSurfacePool();
    surfacePool->initializeVisibleTileBuffer(m_webPage->d->transformedViewportSize());
}

void BackingStorePrivate::createScrollbars()
{
    if (!m_webPage->isVisible())
        return;

    IntSize horizontalSize = IntSize(m_webPage->d->transformedActualVisibleSize().width(), 6);
    IntSize verticalSize = IntSize(6, m_webPage->d->transformedActualVisibleSize().height());

    ASSERT(horizontalSize.width() <= m_webPage->width());
    ASSERT(verticalSize.height() <= m_webPage->height());

    SurfacePool* surfacePool = SurfacePool::globalSurfacePool();
    surfacePool->initializeScrollbars(horizontalSize, verticalSize);
}

WebCore::IntPoint BackingStorePrivate::originOfTile(const TileIndex& index) const
{
    return originOfTile(index, backingStoreRect());
}

WebCore::IntPoint BackingStorePrivate::originOfTile(const TileIndex& index, const WebCore::IntRect& backingStoreRect) const
{
    return IntPoint(backingStoreRect.x() + (index.i() * tileWidth()),
                    backingStoreRect.y() + (index.j() * tileHeight()));
}

int BackingStorePrivate::numberOfTilesWide() const
{
    return m_numberOfTilesWide;
}

int BackingStorePrivate::numberOfTilesHigh() const
{
    return m_numberOfTilesHigh;
}

int BackingStorePrivate::minimumNumberOfTilesWide() const
{
    // The minimum number of tiles wide required to fill the viewport + 1 tile extra to allow scrolling
    return static_cast<int>(ceilf(m_webPage->d->transformedViewportSize().width() / static_cast<float>(tileWidth()))) + 1;
}

int BackingStorePrivate::minimumNumberOfTilesHigh() const
{
    // The minimum number of tiles high required to fill the viewport + 1 tile extra to allow scrolling
    return static_cast<int>(ceilf(m_webPage->d->transformedViewportSize().height() / static_cast<float>(tileHeight()))) + 1;
}

int BackingStorePrivate::tileWidth() const
{
    static int tw = m_webPage->width();
    return tw;
}

int BackingStorePrivate::tileHeight() const
{
    static int th = m_webPage->height();
    return th;
}

WebCore::IntSize BackingStorePrivate::tileSize() const
{
    return IntSize(tileWidth(), tileHeight());
}

WebCore::IntRect BackingStorePrivate::tileRect() const
{
    return IntRect(0, 0, tileWidth(), tileHeight());
}

WebCore::IntSize BackingStorePrivate::expandedContentsSize() const
{
    return m_webPage->d->transformedContentsSize().expandedTo(m_webPage->d->transformedViewportSize());
}

WebCore::IntSize BackingStorePrivate::backingStoreSize() const
{
    return IntSize(numberOfTilesWide() * tileWidth(), numberOfTilesHigh() * tileHeight());
}

BackingStore::BackingStore(WebPage* webPage)
    : d(new BackingStorePrivate)
{
    d->m_webPage = webPage;
}

BackingStore::~BackingStore()
{
    delete d;
    d = 0;
}

void BackingStore::createSurface()
{
    EGLint      majorVersion;
    EGLint      minorVersion;

    // Get EGL display.
    d->m_eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    ASSERT_EGL_NO_ERROR();

    // Initialize EGL on that display.
    eglInitialize(d->m_eglDisplay, &majorVersion, &minorVersion);
    ASSERT_EGL_NO_ERROR();

    // Make sure we are using OpenVG
    eglBindAPI(EGL_OPENVG_API);
    ASSERT_EGL_NO_ERROR();

    EGLDisplayOpenVG::setCurrentDisplay(d->m_eglDisplay);

    // Triggers creation of surfaces in backingstore
    d->createSurfaces();

    EGLDisplayOpenVG::current()->sharedPlatformSurface()->makeCurrent();

    // Focusing the WebPage triggers a repaint, so while we want it to be
    // focused initially this has to happen after creation of the surface.
    d->m_webPage->setFocused(true);
}

EGLDisplay BackingStore::display() const
{
    return d->m_eglDisplay;
}

void BackingStore::repaint(int x, int y, int width, int height,
                           bool contentChanged, bool immediate, bool repaintContentOnly)
{
    d->repaint(IntRect(x, y, width, height), contentChanged, immediate, repaintContentOnly);
}

bool BackingStore::hasIdleJobs() const
{
    return d->hasIdleJobs();
}

void BackingStore::renderOnIdle()
{
    d->renderOnIdle();
}

}
}
